{"meta":{"title":"Ihuzb","subtitle":"生命不息，折腾不止！","description":null,"author":"胡丶某人","url":"http://ihuzb.huzb.vip"},"pages":[{"title":"Contact","date":"2016-10-14T09:11:28.671Z","updated":"2016-10-14T09:11:28.667Z","comments":true,"path":"about/index.html","permalink":"http://ihuzb.huzb.vip/about/index.html","excerpt":"","text":"Phone:15166089918Email:15166089918@163.com"},{"title":"Tags","date":"2016-10-14T06:10:35.415Z","updated":"2016-09-19T14:18:54.000Z","comments":true,"path":"tags/index.html","permalink":"http://ihuzb.huzb.vip/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-10-14T06:10:35.395Z","updated":"2016-09-19T14:18:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://ihuzb.huzb.vip/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Nodejs笔记集锦06","slug":"Nodejs集锦06","date":"2016-11-15T02:20:01.000Z","updated":"2016-11-19T16:39:20.713Z","comments":true,"path":"2016/11/15/Nodejs集锦06/","link":"","permalink":"http://ihuzb.huzb.vip/2016/11/15/Nodejs集锦06/","excerpt":"Nodejs的MVC思想、代码优雅和中间件。","text":"Nodejs的MVC思想、代码优雅和中间件。 mvc思想 Model模型 View视图 Controller控制器 以最少的耦合协同工作，从而提高应用的可扩展行及可维护性 AMD和CMD AMD Require.js CMD sea.js 区别： requirejs是优先加载的（现在头部加载进来） seajs是懒加载的，用的时候才加载 requirejs一切能写的写法，seajs都是支持的 高耦合低内聚 代码优雅—&gt;低耦合高内聚 一个函数只做一个功能（点题)，各功能之间联系不要太紧密，方便别人使用 内聚从功能角度开衡量模块内代码的联系，一个好的内聚模块应当恰好做一件事—–&gt;称之为高内聚 高内聚优势：1.可读性；2.复用性；3.方便维护和修改 耦合是各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 低耦合：1.独立完成任务；2.复用性；3.方便维护和修改 理解高内聚低耦合能是我们更好的理解MVC 中间件 Express是一个自身功能极简，完全是由路由和中间件构成一个web开发框架：从本质上来说，一个Express应用就是在调用各种中间件。 中间件是一个函数，它可以访问请求对象，响应对象，和web应用中处于请求-响应循环流程中的中间件，一般命名为next的变量。 往往一个http请求发送到服务器，都需要通过很多的判断和处理 一个请求发送过来—&gt;用户是否已经登录—》用户请求的是什么资源（静态资源，动态资源，json数据）—》统计一下用户的请求—-》如果请求的内容不存在返回404 中间件的功能包括： 执行任何代码 修改请求和响应对象 终结请求-响应请求 调用堆栈中的下一个中间件 如果当前中间件没有终结请求-响应循环，则必须调用next()方法将控制权交给下一个中间件，否则请求就会被挂起。 app.use(function(req,res,next){})","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://ihuzb.huzb.vip/tags/Nodejs/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"Nodejs笔记集锦05","slug":"Nodejs集锦05","date":"2016-11-14T07:06:20.000Z","updated":"2016-11-19T16:36:35.449Z","comments":true,"path":"2016/11/14/Nodejs集锦05/","link":"","permalink":"http://ihuzb.huzb.vip/2016/11/14/Nodejs集锦05/","excerpt":"Nodejs开发命令行工具和HTTP模块。","text":"Nodejs开发命令行工具和HTTP模块。 nodemon实现保存文件实时重启 安装npm install -g nodemon 使用nodemon server.js 开发命令行工具node脚本，全局可执行 1.在js文件头中加入#!/usr/bin/env node 2.在配置文件的bin属性中，bin:{&#39;zou&#39;:1.js }去写命令，名称可以自定义。 3.在输入npm link将当前包安装到全局去 http模块创建HTTP服务器 http.createServer()通过监听Event:request来进行 server.on(&#39;request&#39;,(request,response)=&gt;{})request、response对象 request对象，用于接收请求报文内的信息 response对象，用于返回响应报文内的信息response.write() write方法用于响应体里写内容，用于向客户端发送信息，可以多次被使用response.end() 再一次请求和响应过程中，只要调用了end就不能在继续write了，就说明你是再一次情趣和响应处理过程中已经结束的响应，但是又去想客户端发送数据，这个时候就会报错server.listen() 监听端口，执行这句，服务正是被启动使用 server.listen(3000,’127.0.0.1’,()=&gt;{console.log(‘server is listening at port 3000’)})request request.headers 请求头 request.method 请求路径 request.url 请求路径 request.httpVersion 请求HTTP协议版本response res.writeHead(200,{‘Content-Type’:’text/html;charset=utf-8’})设置相应报文头 res.write(‘helloword‘) res.end()Content-Type 内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取通过 req.url和req.method的不同给出不同的响应1234567if (req.url == '/' &amp;&amp; req.method == 'GET') &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.write('&lt;h1&gt;首页&lt;/h1&gt;'); res.end(); &#125; request通过data时间和end时间来接受post的数据123456789101112let data = '';req.on('data', (chunk) =&gt; &#123; data += chunk;&#125;); req.on('end', () =&gt; &#123; console.log(data); res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.write('&lt;h1&gt;收到数据了&lt;/h1&gt;'); res.end(); &#125;); 通过 querystring解析post的数据12querystring.parse('foo=bar&amp;baz=qux&amp;baz=quux&amp;corge')// returns &#123; foo: 'bar', baz: ['qux', 'quux'], corge: '' &#125; url123456- url.parse(urlStr, [parseQueryString], [slashesDenoteHost])urlStr-&gt;url字符串parseQueryString-&gt;为true时将使用queryString分析查询字符串，默认为falseslashesDenoteHost默认为false，//foo/bar 形式的字符串将被解释成 &#123; pathname: ‘//foo/bar&apos; &#125;如果设置成true，//foo/bar 形式的字符串将被解释成 &#123; host: ‘foo&apos;, pathname: ‘/bar&apos; &#125; 服务器相关操作事件和API Event: ‘close’ Event: ‘connection’ Event: ‘request’ server.close([callback]) server.listen(port[, hostname][, backlog][, callback])请求对象 Event: ‘data’ message.headers message.httpVersion message.method message.url require(‘url’).parse(request.url) require(‘url’).parse(request.url, true)响应对象 response.end([data][, encoding][, callback]) response.setHeader(name, value) response.statusCode response.statusMessage response.write(chunk[, encoding][, callback]) response.writeHead(statusCode[, statusMessage][, headers])","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://ihuzb.huzb.vip/tags/Nodejs/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"Nodejs笔记集锦04","slug":"Nodejs集锦04","date":"2016-11-12T14:10:01.000Z","updated":"2016-11-19T16:34:09.595Z","comments":true,"path":"2016/11/12/Nodejs集锦04/","link":"","permalink":"http://ihuzb.huzb.vip/2016/11/12/Nodejs集锦04/","excerpt":"Nodejs的Session,Cookie,HTTP协议。","text":"Nodejs的Session,Cookie,HTTP协议。 前端代码优化 1.代码压缩 打包 节省网络资源 (gulp)压缩、合并等等 2.减少对于对象、数组的遍历 (单页面引用操作还行，页面有在前端拼接和后端拼接的区别) 3.减少dom操作 也是减少js代码的途径 4.10s内好的用户体验 5.能提前算好的提前算好 Buffer 用于文件读取显示文件 文件流 流对象 stream pipe() 管道 应用服务器 阿帕奇 对外提供服务的程序，应用服务器就是一个应用程序，作为服务器执行共享业务应用程序的底层的系统软件 web服务器 和应用服务器一样都是程序 Node node本身就是web服务器 node不需要服务器容器，本身就是web应用的容器 协议 约定规则，方便做通信 网络之间传输数据就需要协议 所谓的协议就是双方约定好的一些数据格式 否则两台计算机之间如何识别对方发送过来的01数据。 HTTP概念 其实就是用通讯的，提供很多方便 因为TCP 才能稳定传输，三次请求，四次挥手 HTTP超文本传输协议，是一种通信协议，允许将超文本标记约言文档从web服务器传送到客户端的浏览器 用于客户端和服务器的通信协议，我按照一定的格式发送，服务器按照一定的格式接收 请求报文 请求行 请求体，只有在post的时候才有请求体，响应的时候也有请求体 响应报文 响应行 响应体 跨域解决 服务器请求服务器 分布式服务器系统 HTTP是无状态的协议 使用HTTP协议，每当有新的请求时，就会有对应的新响应产生协议本身并不保留之前的一切的请求或响应报文的信息，这是为了更快的处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单。 Cookie（信物） 1.保存请求》2.生成Cookie记住是想谁发送的》3.在响应中添加Cookie后返回》4.保存在浏览器 Session 为了解决Cookie无法存储大量数据，以及不安全的问题，Session被设计出来了 Session存储方式 存储在内存中 Redis、Memcached内存数据库等高效的缓存服务其技术 Redis可以与mysql之间数据的同步 Cookie总结 http是一个无状态的协议，每次去请求服务器的时候，服务器是不能记住客户端的 Cookie信物，客户端请求服务器以后，服务器给客户端一个信物，下次客户端再请求服务器的时候，给服务器这个信物服务器就知道是那个客户端了，但缺点是，不能存储太多内容，不安全 seccion 存储在服务器短的，保存着用户信息的，和Cookie搭配来使用，可以用Cookie里面的key对应上session里面的值，session可以存储在内存和硬盘上都可以。 HTTP 模块 用来编写服务器 localhost是不走网卡，直接找本地 127.0.0.1会走网卡，ip的话会走网管123456789101112const http=require(&apos;http&apos;)//创建一个服务，创建一个服务器的实例var server=http.createServer();//接收到请求就出发此事件，request对象用来存储请求报文中的信息，response对象用来帮助我们封装响应报文//response对象是一个写的流对象server.on(&apos;request&apos;,(request,response)=&gt;&#123;response.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;&quot;text/html;charset:utf-8;&quot;&#125;)response.write(&apos;lalalal&apos;)//返回的响应response.end(&apos;hello world&apos;)&#125;)server.listen(3000)","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://ihuzb.huzb.vip/tags/Nodejs/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"Nodejs笔记集锦03","slug":"Nodejs集锦03","date":"2016-11-10T10:20:20.000Z","updated":"2016-11-19T16:29:12.877Z","comments":true,"path":"2016/11/10/Nodejs集锦03/","link":"","permalink":"http://ihuzb.huzb.vip/2016/11/10/Nodejs集锦03/","excerpt":"Nodejs事件驱动模型,基本模块:path,fs等。","text":"Nodejs事件驱动模型,基本模块:path,fs等。 理解I/O I/O的意义 io是输入，文件操作的读写，网络操作中的请求和应答 out是输出 异步I/O与事件驱动 什么是进程？ 运行当中的应用程序有关，进程是为当前运行当中的应用程序提供运行环境的，一个运行当中的应用程序就会有一个进程与之相对应 什么事线城？ 线程是用来运行应用程序中的代码的，一个线程在一个时间只能做一件事情，多线程，调度起来很麻烦，node是单线程执行，用异步替代了多线程 多线程问题 需要各线程之间调度，并且逻辑复杂 单线程特点 先执行同步，后执行异步 虽然是单线程，但是底层自己会处理多线程，还有很多子线程 异步非i/o操作和异步i/o操作 异步非i/o settimeout setinterval 异步i/o 操作文件，网络操作 fs js运行时会放到代码队列中去 如果回调函数里卖弄都是同步代码，有主线程执行，里面有异步非io代码，看条件去执行，异步io代码，再去拽出一个子线程执行 进程和线程？ 进程是为运行中的应用程序提供运行环境的 线程是执行应用程序当中的代码的，同一时间只干一件事情 node中的异步就是帮助完成多线程编程 同步和异步？ 同步会阻塞代码 异步不会阻塞代码 事件驱动模型 主线程： 1.执行node的代码，把代码放入队列 2.事件循环程序（主线程）把队列里面的同步的代码都先执行了 3.同步代码执行完成，执行异步代码 4.异步代码分2种情况 1.异步非io setTimeout() setInterval() 2.异步io 文件读写操作等，主线程会从线程池中去取一条线程，帮助主线程去执行 子线程：被放在线程池里面的线程，用来指导异步io操作 1.在线程池中休息 2.异步io的操作来了，执行异步io操作 3.子线程会把异步io操作的callback函数，扔回给队列 4.子线程会回到线程池里去休息 在异步io代码执行完成的时候被扔回主线程 文件操作 fs.readFile() 读取文件 fs.writeFile() 写文件 fs.access() 判断路径中有没有此文件 fs.appendFile() 在文件的内部追加一些内容 fs.mkdir() 创建文件夹 fs.stat() 判断文件文件夹，文件/文件夹的属性（异步） fs.statSync()判断文件文件夹，文件/文件夹的属性（同步）- path123456789101112var path = require('path')//拼接正确路径var p = path.join(__dirname, \"text.html\")//查找路径中的文件夹var p1 = path.dirname('/test/node_modules/rd/index.html')//获取路径中的文件格式var p2=path.extname('/test/node_modules/rd/index.html')//获取文件名var p3=path.basename('/test/node_modules/rd/index.html')//获取去掉后缀名的文件名var p4=path.basename('/test/node_modules/rd/index.html','.html')console.log(p3) 异常 错误—-》异常 计算机解决不了的问题 var err=new Error(&#39;这是我自定义的错误对象！&#39;) throw err 属性 err.message错误信息 err.stack错误堆栈信息 err.code=100设置错误号 try{代码报错}catch(error){发生异常的操作}异步里面的tfrow，try捕捉不到异步执行时报出的错误es6 ECMAScript 定义js的发展方向的一套标准 新的语法，写起来更严谨更安全更简便 为什么前端不用，node要用？ node——-&gt;v8执行js代码 node不考虑兼容性，es6能给我带来很多好处 node.js 版本6系列，覆盖了93%的ECMAScript6 严格模式 use strict 表示一下表示所写代码为新语法，严格模式es5的语法，一种过渡形式，开发就愈发，又有人用新语法 消除js语法的一些不合理，不严谨指出，减少一些怪异行为 消除代码运行的一些不安全指出，保证代码运行的安全 提高编译器效率，增加运行速度 为未来新版本的js做好铺垫 let一个变量名只能生命一次，不存在命名冲突，let定义作用域在代码快利，解决命名冲突问题，能体现代码的封装性。 const定义常量，不会发生变化，如果定义了常量，再去修改就会报错 Buffer()是一个像Array的对象，主要用于操作字节，是一个全局对象，使用的是时候不需要require 流 const rs=fs.createReadStream(path1) const ws=fs.createWriteStream(path1) rs.pipe(ws)","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://ihuzb.huzb.vip/tags/Nodejs/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"Anaular流行框架 第三天","slug":"流行框架03","date":"2016-11-05T18:10:05.000Z","updated":"2016-11-03T17:00:58.570Z","comments":true,"path":"2016/11/06/流行框架03/","link":"","permalink":"http://ihuzb.huzb.vip/2016/11/06/流行框架03/","excerpt":"Anaular流行框架,基本指令,自定义指令,Angular服务。","text":"Anaular流行框架,基本指令,自定义指令,Angular服务。 基本指令 ng-app:相当于一个入口，告诉angular来管理我们页面的html代码 ng-click:用于注册点击事件 ng-model:用于进行双向数据绑定 ng-init:用于初始化数据模型 ng-controller:指向了创建的控制器 ng-bind:能够绑定数据模型的值，只能能作用于双标签元素 ng-cloak:利用了angular会移除所有样式名为ng-cloak的样式的特性 ng-bind-html:用于安全的渲染html代码ngSanitize搭配食用 ng-repeat:渲染数据列表，ng-repeat=“item in data” ng-class:操作样式 {key001：样式名001，key2：样式名002}[‘key001’] {‘样式名001’:布尔值，’样式名002’:布尔值} ng-hide/ng-show:显示或隐藏页面元素 ng-if/ng-swith ng-switch-when 自定义指令 通过模块对象directive方法创建 有两个参数，第一个参数，是指令的名字，驼峰命名法或者小写命名，第二个参数和控制器的第二个参数一样那个，在第二个参数function里直接返回一个obj对象 使用时：需要将指令的名字转换成小写，并以-分割原先在的大小写字母 例子：123456app.directive('myben',function()&#123;//需要返回一个对象 return&#123; console.log(343) &#125;&#125;) template:需要一个字符串，最终这个字符串值被添加到自定义指令所在的标签的innerHtml位置 1.创建定义指令 12345app.directive('myBtn',[function()&#123; return&#123; template:'&lt;button&gt;我是button&lt;/button&gt;' &#125; &#125;]); 2.定义指令的引用 &lt;div my-btn&gt;&lt;/div&gt; templateUrl:需要一个字符串，这个字符串是一个文本文件的路径，anuglar最终会异步请求这个文件，把拿到的内容插入到自定义指令所在的innerHtml位置，该字符串也可以是script标签的id值，把script标签中的内容当作模板字符串来使用 1.第一种用法 templateUrl：’./view.html’ 注意：要通过静态文件服务器查看，因为获取./view.html的方式是一个get请求 2.第二种用法 通过id指向一个templateUrl:’tp1’ 123&lt;script id=\"tpl\" type=\"text/ng-template\"&gt; &lt;button&gt;我是button&lt;/button&gt; &lt;/script&gt; 注意：script的type属性需要为“text/ng-templte” restrict:也是需要一个字符串，可以使A,E,C这3个字符中任何一个，也可以任意的组合 A 以属性的形式使用 B 以自定义标签的形式使用 C 表示以类样式名的形式使用 1.在返回的对象中添加控制，如果不写默认是AE restrict:’EAC’ //restrict用来限制自定义呈现形式 2.123&lt;my-hello&gt;&lt;/my-hello&gt; &lt;div my-hello&gt;&lt;/div&gt; &lt;div class=\"my-hello\"&gt;&lt;/div&gt; replace:脱壳，需要一个布尔值，为true，会将自定义指令所在的标签替换为模板字符串 只可以添加一个标签 transclude:转置，是需要一个布尔值，为true时会把自定义指令所在的标签的innerHTML值添加到模板字符串中 不能与replace指令同用 link:指向一个function，这个function有三个参数： scope：类似于控制器中的$scope，也可以暴露一些值 element：这是一个jqLite对象，是自定义指令所在的标签的jaLite对象 attributes：是自定义指令所在标签的所有属性的集合123456789101112return &#123; link:function (scope,ele,attr) &#123; console.log(scope); console.log(ele); console.log(attr); //ele就是咱们的jqLite元素 ele.on('click',function () &#123; console.log('这是jqLite的做出来的log'); &#125;) //在angular中所有的dom处理建议在自定义指令中完成 &#125; &#125; Angular服务 什么是服务 在AngularJS中，服务是一个函数或对象，可在你的AngularJS应用中使用，AngularJS内建了30多个服务 AngularJS内建了30多个服务 $scope:作用域，用来负责连接View和Controller，也就是MVVM中的ViewModel想点故意桥梁一样 $log $interval和setInterval区别 1234567891011$interval和setInterval区别 在数据变换过程中有时候angular监视不到数据变化: setInterval(function () &#123; $scope.time=new Date(); console.log($scope.time); $scope.$apply();//告诉angular进行数据更新 &#125;,1000) //但是如果说使用 $interval这种angular的服务有时候服务内部就帮我们完成了这种数据更新 $interval(function () &#123; $scope.time2=new Date(); &#125;,1000) 创建服务 通过model创建：service，factory service创建： 123app.service('myService',function () &#123; this.name='myService'; &#125;); factory创建: 12345678app.foctory('myAPP',function()&#123; return&#123; name:\"34234\", log:function()&#123; console.log(2323) &#125; &#125;&#125;)","categories":[],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://ihuzb.huzb.vip/tags/Angular/"}],"keywords":[]},{"title":"Nodejs笔记集锦02","slug":"Nodejs集锦02","date":"2016-11-05T12:16:20.000Z","updated":"2016-11-19T16:25:24.519Z","comments":true,"path":"2016/11/05/Nodejs集锦02/","link":"","permalink":"http://ihuzb.huzb.vip/2016/11/05/Nodejs集锦02/","excerpt":"Nodejs模块的使用和箭头函数。","text":"Nodejs模块的使用和箭头函数。 模块的种类 第一类 核心模块，node自带，用名称即可 fs http os path querystring url 第二类 文件模块，用路径加载，有一种特殊的文件模块——&gt;包 将多个js组合在一起完成某个功能，使用时直接调用即可 目录结构 必须要有package.json和index.js package.json 包描述文件，说明文件 Bin 存放可执行二进制文件 Lib 存放javascript代码 Doc 存放文档的目录 Test 村昂单元测试用例的代码 require的加载流程 1.判断是否在文件模块的缓存区中 1.1 若在返回module.exports 1.2 判断是否是原生模块 1.2.1 若是判断是否在原生模块的缓存区中 1.2.1.1若是直接返回module.exports 1.2.1.2 若不是 1.2.1.2.1加在这个模块 1.2.1.2.2 module对象加载到原生模块缓存区中，返回modul.exports 1.2.2 若不是 1.2.2.1 查找文件，看文件模块是不是真的存在 1.2.2.2 加在这个文件模块 1.2.2.3 缓存module对象加在到文件模块的缓冲区中 返回modul.exportsrequire 自动补足文件名 优先加载js文件 globals __dirname和__filename __dirname:当前js文件所在的路径 __filename:当前js文件所在的路径和文件名 npm npm install 包名 执行npm install的时候，会自动跑到npm网站，然后找到该报的github地址，下载压缩包，并在当前目录下找或者创建一个叫做node_modules目录，解压到该目录下 npm install 当执行的时候，会自动在当前目录中查找package.json文件，如果有，安装该字段所有依赖的项 npm install –save 生产环境 咱们以后在做项目的时候，先初始化一个package.json文件，在安装第三方包依赖的时候，必须使用npm install –save express,添加依赖项到package.json文件中，实际就是添加到dependencies字段中 npm install -save-dev 开发环境 咱们以后在做项目的时候，先初始化一个package.json文件，在安装第三方包依赖的时候，必须使用npm install –save express,添加依赖项到package.json文件中，实际就是添加到dependencies字段中 npm docs +包名 调出相关的文件 npm这种东西的最终的目的就是：让你的开发模式工程化，都依靠工具来管理 3m nvm npm nrm nvm node版本的管理工具 npm node的包管理工具 nrm npm的数据源管理工具 箭头函数(ES6) 箭头函数就是一种语法糖，用这种语法能尝到甜头，使编程高校 当函数体有一个参数有返回值的时候 var foo=function(v){return v} var foo=v=&gt;v 当函数体没有参数有返回值的时候 var foo=function(){return v} var foo=()=&gt;v 当函数体有多个参数有返回值的时候 var foo=function(v1,v2){return v1+v2} var foo=(v1,v2)=&gt;v1+v2 当函数体没有多个参数没有返回值的时候 var foo=function(v1){console.log(v1)} var foo=(v1)=&gt;{console.log(v1)} 文件读写 fs.readFile()读文件 file 读文件的路径 options 用[]包裹的可选参数，object {“encoding”:”uft8”,”flag”:”r”} string ‘utf8’ callback function callback函数里面有两个参数 err表示错误对象，如果readFile发生错误了，在callback函数里面会回返回err，err对象里面存着错误信息 如何读文件成功，err为null data就是读文件，读出来的内容。 fs.access(path,[mode], callback) 用来判断文件是否存在 path 判断路径是否正确（也可以判断文件）’./pic’ mode一般不用，默认就可以了，用的话是用来判断文件是否可读可写可执行//callback 只有一个参数err，错，文件有问题 fs.writeFile() 写文件 fs.appendFile() 在文件的内部去追加写一些内容 fs.mkdir() 创建文件夹 fs.access() 判断路径 fs.stat() isFile：用于判断被查看的对象是否为一个文件，如果是返回true，否则，返回false； isDirectory：用于判断被查看的对象是否为一个目录，如果是的话则返回true，否则，返回false； fs.readdir() 读一个路径","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://ihuzb.huzb.vip/tags/Nodejs/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"Anaular流行框架 第二天","slug":"流行框架02","date":"2016-11-02T17:16:10.000Z","updated":"2016-11-03T17:02:39.333Z","comments":true,"path":"2016/11/03/流行框架02/","link":"","permalink":"http://ihuzb.huzb.vip/2016/11/03/流行框架02/","excerpt":"Anaular流行框架,$scope,MVVM，常用指令和事件。","text":"Anaular流行框架,$scope,MVVM，常用指令和事件。 框架和node用途 公司需要使用某种框架 前端MVC发展过程 在jq之前很多框架，将ajax封装到非常方便的请求的一种程度，把一些样式和组件封装起来， $scope的生命周期 创建controller的时候，生成的$scope 没有创建controller的时候，在标签中写了个ng-model绑定属性，内部也创建了controller产生了$scope。 前端MVC 没有完全达到后端分层的效果 代码更加结构化，便于维护 MVVM Angular称之为MVVM框架 $scope实际就是MVVM中所谓的VM（视图模型） 正因为$scope在Angular中大量使用甚至盖过了C（控制器）的概念，所以很多人把Angular称之为MVVM框架 1.m是model v是view vm是viewmodel 2.MVVM实在MVC基础上抽取出来的思想，VM与C的区别，$scope比较重要，重要到代替了控制层（controller），vm视图模型就是$scope，$scope特点双向绑定，控制层来控制$scope来处理具体的业务 3.双向数据绑定就是v试图与vm视图模型进行了绑定，$scope修改数值页面中相应绑定了的会发生变化 4.m模型拼接json往后台传 5.m：是做数据跟后台交互 v：界面用户看到的 vm：$scope跟视图做的双向数据绑定，视图和视图模型做双向数据绑定。 6.vm跟mvc的区别：vm已经替代controller使其功能淡化，渐渐的称之为mvvm。 ViewModel $scope实际上就是MVVM中所谓的VM（视图模型） 只是因为$scope在Angular中大量使用甚至盖过了C（控制器）的概念，所以很多人把Angular称之为MVVM框架 Angular全局Api使用 数据比较API angular.isArray() 判断给定的对象是否为数组。 angular.isDate() 判断给定的对象是否为日期类型。 angular.isDefined() 判断给定的对象是否定义过。 angular.isElement() 判断给定的对象是否为一个DOM元素。 angular.isFunction() 判断给定的对象是否为一个函数。 angular.isNumber() 判断给定的对象是否为数字。 angular.isObject() 判断给定的对象是否为object类型。 angular.isString() 判断给定的对象是否为字符串。 angular.isUndefined() 判断给定的对象是否没有定义过（与angular.isDefined()相反）。 angular.equals() 判断给定的两个对象是否相等。 其他API使用 angular.lowercase() 将字符串转换为小写形式。 angular.uppercase() 将字符串转换为大写形式。 angular.copy() 深拷贝一个对象或数组。 angular.forEach() 遍历对象或数组中的每一个元素并执行一个函数。 模块控制器的作用 初始化属性 暴露属性或者行为 监视数据变化12345$scope.name=&apos;&apos;;$scope.$watch(&apos;name&apos;,function (newVal,oldVal) &#123; console.log(newVal); console.log(oldVal);&#125;) 控制器代码压缩问题 当代码进行js压缩的时候controller里面的内容会被当作变量替换掉，为了防止这个问题发生，在controller中出现controller(&#39;myapp&#39;,[&quot;$scope&quot;,function($scope){}]) 控制器多种写法 1.标准写法 app.controller(&#39;myCtrl&#39;,function(){}) 2.早期使用（angular-1.2.29版本） 123function myController(\\$scope) &#123; $scope.name=&quot;angular早期使用&quot;; &#125; 3.function写在外面 1234function otherCtrl($scope) &#123; $scope.name=&apos;123&apos;; &#125;app.controller(&apos;myCtrl&apos;,otherCtrl) 4.function写在外面,防止被压缩 123456function otherCtrl(otherscope) &#123; otherscope.name=&apos;123&apos;;&#125;//依赖注入otherCtrl.$inject=[&apos;$scope&apos;];//这里对方法添加$injectapp.controller(&apos;myCtrl&apos;,otherCtrl) 5.面向对象方法使用 1.控制器的function不写改为引用function app.controller(‘myCtrl’,demoCtrl); 2.创建一个面向对象的function function demoCtrl() {this.name=&#39;123&#39;;} 3.使用的时候添加 as scope ng-controller=”myCtrl as scope” controller控制器控制器作用 初始化属性 暴露属性或者行为 监视数据变化 依赖注入 没事你不要来找我，有事我会去找你 为什么不能更改$scope： callback所写的函数中的$scope会在内存中创建一个空间，名字就叫做$scope，函数能所写的变量，就是$scope的key，所写的值就是value，angular会将$scope.key=value转换成字符串，angular使用正则表达式截取指定的$scope，才会将响应的key和value获取到并显示在指定控制器的指定表达式中 原理： 框架在调用方法的过程中通过获取到传递的参数，然后框架内部将方法toString处理后，在通过正则表达式将其获取到然后依次实例化 指令 ng-bind用来解决表达式闪烁问题，使用&lt;p ng-bind=&quot;name&quot;&gt;&lt;/p&gt;替换&lt;p&gt;&lt;/p&gt; ng-cloak页面加载完成后会去除掉所设置的样式,用来解决表达式闪烁问题123456&lt;style&gt; .ng-cloak&#123; display:none &#125;&lt;/style&gt;&lt;p class=&quot;ng-cloak&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; ngSanitize模块 下载安装：npm install angular-sanitize ng-bind-html输出标签 &lt;p ng-bind-html=&quot;name&quot;&gt;&lt;/p&gt; ng-repeat循环输出 可以用来循环输出数组 写在那个元素上就是循环那个元素 语法：类似于for in循环 还可以用来渲染key，value对 $even:提供了一个布尔值，当为true时表示当前数据是第偶数条数据,从索引0开始计算 $odd:提供了一个布尔值，当为true时表示当前数据是第奇数条数据,从索引0开始计算 &lt;div ng-repeat=&quot;item in data &quot;&gt;&lt;/div&gt; ng-class 多种样式中选择一个样式 ng-class=&quot;{&#39;A&#39;:&#39;red&#39;,&#39;B&#39;:&#39;blue&#39;,&#39;C&#39;:&#39;green&#39;}&quot; 从多种样式中选择多个 语法：也是写一个key,value对象，这里的key是我们提供的类样式名，value是一个布尔值，为true时对应的key会被作为样式名加入到class中 ng-hide/ng-show ng-hide：需要一个布尔值：当为true时为隐藏当前元素 ng-show: 需要一个布尔值：当为true时为显示当前元素 ng-switch ng-switch:与ng-switch-when同用，类似与js中的switch case12345&lt;div ng-switch=\"name\"&gt; &lt;div ng-switch-when=\"小明\"&gt;我是小明&lt;/div&gt; &lt;div ng-switch-when=\"小红\"&gt;我是小红&lt;/div&gt; &lt;div ng-switch-when=\"小月\"&gt;我是小月&lt;/div&gt;&lt;/div&gt; 其它指令 ng-checked： 单选/复选是否选中,是单向数据绑定 ng-selected： 是否选中 ng-disabled： 是否禁用 ng-readonly： 是否只读 常用时间指令 ng-blur：失去焦点 ng-focus：获得焦点 ng-change：改变事件 ng-click： ng-click=”add()” ng-dblclick：双击事件 ng-submit： 表单提交事件","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://ihuzb.huzb.vip/tags/Angular/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"Nodejs笔记集锦01","slug":"Nodejs集锦01","date":"2016-11-01T11:30:20.000Z","updated":"2016-11-19T16:21:41.121Z","comments":true,"path":"2016/11/01/Nodejs集锦01/","link":"","permalink":"http://ihuzb.huzb.vip/2016/11/01/Nodejs集锦01/","excerpt":"Nodejs特点、优势和使用。","text":"Nodejs特点、优势和使用。 学前思考 1.前端、后端都是干什么的？ 前端：写静态文件的html css js 后端：操作服务器的硬件 2.什么事JS？ 解释性脚本语言 3.浏览器的JS可以做什么？ 操作DOM提交表单等等 4.浏览器中的JS不可以做什么？ js不能操作硬件， 5.浏览器与JS是什么关系？ js引擎——》就是内核 引擎的第一特点：转化 发动机——》汽油转化成动力，终点再转化 模板引擎—-》数据+模板—–》页面 js代码通过—–》js引擎——》字节码或者机器码 引擎的第二特点：可移植性 6.js只可以运行在浏览器中嘛？ js靠我们的js引擎解析 Nodejs运行js，node给V8引擎包一层壳，黑匣子 node特点 事件驱动，无阻塞的I/O模型 适合于高并发的场景，不适合cpu密集型场景 node优势 轻量，高效 node与js的关系 node是js运行时平台，提供运行时环境 node基于js那个引擎？ V8引擎，v8升级node也会升级，v8会根据js的规范标准升级， node使用 只要在js中，所有的定义之定义在文件本身，作用域永远在文件内，但是global是全局的，不会添加此对象数据 console.assert()断言，下一个结论看对不对,第一个参数是判断条件，第二个参数内容是报错信息 console.time(&#39;kaishi&#39;) and console.timeEnd(&#39;kaishi&#39;)成对使用，计算执行时间，传进的字符必须一样 __dirname:当前执行的文件所在的文件夹路径 __filename:当前文件所在的文件夹的路径+文件名 process:全局可用对象，用来和我们现在启动中的node进行交互 nodejs模块化 以module.exports为优先，module.exports一旦被定义，exports就靠边站 什么事模块 一个文件就是一个模块 模块作用域 在一个模块内变量、函数、对象都属于这个模块，对外是封闭的","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://ihuzb.huzb.vip/tags/Nodejs/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"Anaular流行框架 第一天","slug":"流行框架01","date":"2016-10-29T12:16:10.000Z","updated":"2016-11-02T16:40:27.073Z","comments":true,"path":"2016/10/29/流行框架01/","link":"","permalink":"http://ihuzb.huzb.vip/2016/10/29/流行框架01/","excerpt":"Anaular流行框架,CDN,MVC。","text":"Anaular流行框架,CDN,MVC。 概念 流行 框架 什么是库，什么是框架 库：封装了一些常用的方法，主动调用这些方法，提高代码的利用，一级代码后期的维护 框架：提供了一些结构或者模式，根据结构提供的结构或者模式去书写，由框架帮助我们去执行响应的擦操作 CDN CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。 Angular 一款非常优秀的前端好几JS框架 有了这一了框架就可以轻松构建SPA应用程序 SPA应用程序：单页面应用程序，模拟cs结构客户端服务器，做出的bs的机构的网站，但是带有客户端的功能行/页面局部刷新特点 核心就是通过指令扩展了HTML，通过表达式绑定数据到HTML Angular不推荐DOM操作，也就是说在NG中几乎找不到任何的DOM操作 Angular使用Angular指令 ng- 以ng-开头的标签里面的属性的扩展形式称之为指令 &lt;body ng-app&gt;ng-开头的这种，像标签属性的这种写法叫指令，ng-app告诉angulat从这里开始管理代码 ng-model=&quot;val&quot;用ng-model这个指令去绑定当前这个input输入框的值 ng-click=用ng-click添加点击事件 ng-init=初始化一个对象的值 Angular表达式 123456- 不能写json对象## Anaular处理- 现在body标签添加```javascript&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;demo&quot;&gt; 定义一个模块 第一个参数与ng-app的值对应 第二个参数数组必须要写 如果不屑表示调用一个模块 1var app=angular.module(\"myApp\",[]); 创建一个控制器 1234app.controller(\"demo\",function($scope)&#123;$scope.user=&#123;&#125;;$scope.user.name=\"飞飞\"&#125;) MVC MVC(Model View Controller 模型-视图-控制器) M:Model 模型 数据存储，一些业务逻辑 V:View 试图 就是用来展示数据 C:Controller 控制器 调度业务逻辑 双向数据绑定 数据模型的值发生改变，就会导致页面值得改变 页面值得改变，就会导致数据模型值得改变，这各种相互影响的关系就是双向数据绑定 单向数据绑定 使用表达式显示数据模型的值 $watch 用于监视数据模型的变化（并且只能监视数据模型的变化） $scope.$watch(&#39;数据模型名的字符串形式&#39;，function(变化后的值，变化前得值)) $scope.$watch里的回调函数会默认执行一次 工作流程 需求文档》设计》前端制作页面》交给后端完成一个网站","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://ihuzb.huzb.vip/tags/Angular/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"Canvas第三天","slug":"Canvas03","date":"2016-10-25T14:45:03.000Z","updated":"2016-10-20T14:38:40.189Z","comments":true,"path":"2016/10/25/Canvas03/","link":"","permalink":"http://ihuzb.huzb.vip/2016/10/25/Canvas03/","excerpt":"Canvas 第三天,文字预测,状态的保存与回滚,平移,requestAnimationFrame,图像API。","text":"Canvas 第三天,文字预测,状态的保存与回滚,平移,requestAnimationFrame,图像API。 文字预测 ctx.measureText(文本) 返回值：一个对象，该对象有一个width属性，代表这段绘制时所需的长度 状态的保存与回滚 状态：就是变量或者属性不同属性的值 ctx.save()状态的保存，就是把绘图对象所有的属性的状态值copy保留一份 save方法会把绘图环境自身所有的属性保存一份，其中有些属性对我们是可见的，可以通过ctx来获取到的属性值。 没有和路径相关状态，即save不会保存路径 状态的保存与回滚，没有任何瓜葛 ctx.resotr()状态的回滚，把之前保存的状态拿出来，覆盖当前的状态 平移 ctx.translate(x轴平移多少，y轴平移多少) 这里的平移画布的坐标系，平移不会影响已经绘制好的图形 平移可以累加 旋转 ctx.rotate(当前基础上旋转弧度) 这里旋转的是画布的坐标系，旋转不会影响已经绘制好的图形，旋转会累加 缩放 ctx.scale(在当前基础上x轴缩放多少倍，在当前基础上y轴缩放多少倍) 这里缩放的是画布的坐标系，缩放不会影响已经会治好的图形，缩放会累加 requestAnimationFrame requestAnimationFrame请求动画帧 使用方法和setTimeout一致，只是不需要传时间 当浏览器要刷新页面的时候，才会调用传入该方法的回调 这个方法的执行频率比较稳定，这个方法是专门用来开发游戏shi Object.keys 语法：Object.keys 返回值：该对象自己的，并且是可枚举的属性构成的数组 这是ES5新增的一个方法，用来获取对象所有的自己的并且是枚举的属性，不会去继承的对象中查找属性，所以会快一些 撞柱API（路径点判断） ctx.isPointInPath(x坐标，y坐标)判断指定坐标的店在不在当前的路径内 描边和填充问题 先填充后描边，最终描边宽度和设置的线宽一致 先描边后填充，描边宽度会有一般被填充覆盖","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://ihuzb.huzb.vip/tags/Canvas/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"递归求斐波那契性能优化","slug":"递归求斐波那契性能优化","date":"2016-10-22T11:01:01.000Z","updated":"2016-10-30T15:44:12.898Z","comments":true,"path":"2016/10/22/递归求斐波那契性能优化/","link":"","permalink":"http://ihuzb.huzb.vip/2016/10/22/递归求斐波那契性能优化/","excerpt":"所求位数若超过45位浏览器将无响应，可使用优化版本，性能超棒","text":"所求位数若超过45位浏览器将无响应，可使用优化版本，性能超棒 未优化版本1234567891011121314151617//目前为止设置的位数无法超过45，超过45浏览器将无响应，可使用下面的优化版本，性能超棒 var tt = 0； //记录执行次数 function feibo(n) &#123; tt++； //执行一次加1 if (n === 0 || n === 1) &#123; cunshu = 1； &#125; else &#123; cunshu = feibo(n - 2) + feibo(n - 1)； &#125; return cunshu； &#125; console.log(feibo(40)); //执行结果：165580141 console.log(\"执行次数:\" + tt)； //执行次数：331160281 优化版本1234567891011121314151617181920212223242526272829303132var arr = []//创建一个用来存储每次求斐波那契数的结果的数组var cunshu = null//用来存储得到的结果var tt = 0//记录执行次数function feibo(n) &#123; tt++ //执行一次加1 if (arr[n]) &#123; //判断数组中有没有需要的数据，若有直接返回数据，若没有继续执行进行计算 return arr[n] &#125; if (n === 0 || n === 1) &#123; cunshu = 1 &#125; else &#123; cunshu = feibo(n - 2) + feibo(n - 1) &#125; arr[n] = cunshu //将在变量中存储的数据存储到数组中 return cunshu //将变量中的数据返回&#125;console.log(feibo(500));//执行结果：20365011074console.log(\"执行次数:\" + tt)//执行次数：99tt = 0console.log(feibo(500));//执行结果：20365011074console.log(\"再次执行次数:\" + tt)//执行次数：1","categories":[{"name":"性能优化技巧","slug":"性能优化技巧","permalink":"http://ihuzb.huzb.vip/categories/性能优化技巧/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"性能优化技巧","slug":"性能优化技巧","permalink":"http://ihuzb.huzb.vip/categories/性能优化技巧/"}]},{"title":"jQuery入口函数结构解析","slug":"jq入口函数结构解析","date":"2016-10-20T14:45:03.000Z","updated":"2016-10-30T15:44:12.973Z","comments":true,"path":"2016/10/20/jq入口函数结构解析/","link":"","permalink":"http://ihuzb.huzb.vip/2016/10/20/jq入口函数结构解析/","excerpt":"jQuery入口函数结构解析","text":"jQuery入口函数结构解析 代码整体过长，故切分进行展示12345678910111213&lt;script&gt; /* * 入口函数的处理： * 1、如果传入空，直接返回空实例 * 2、如果传入函数，把这个函数作为事件句柄添加到DOMContentLoaded事件中 * IE8不知道该事件，需要通过onreadystatechange事件来兼容处理 * 3、如果传入字符串，需要判断这个字符串是不是html片段，如果是， * 就通过innnerHTML把它转为DOM元素，结果分别添加到实例中； * 如果不是，就当做选择器获取页面中的DOM元素，结果分别添加到实例中。 * 4、如果传入的是DOM对象，那么直接添加到实例中。 * 5、如果传入伪数组，那么把伪数组中的每一项值分别添加到实例中。 * 6、其他类型的数据，直接添加到实例中。 * */ 1234567891011121314151617181920// 为了全局变量污染，把代码写到自调函数中(function ( w ) &#123; // 为了用户使用方便，提供一个工厂函数 function jQuery( selector ) &#123; return new init( selector ); &#125; // 原型简写&amp;原型默认拥有的属性与方法 jQuery.fn = jQuery.prototype = &#123; constructor: jQuery, isReady: false &#125;; // 给jQuery自身以及原型添加一个extend方法 jQuery.extend = jQuery.fn.extend = function ( obj ) &#123; for ( var key in obj ) &#123; this[key] = obj[key]; &#125; &#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 添加静态方法jQuery.extend(&#123; // 判断是不是函数 isFunction: function( func ) &#123; return typeof func === 'function'; &#125;, isString: function( str ) &#123; return typeof str === 'string'; &#125;, // 判断是不是DOM isDOM: function( dom ) &#123; return !!dom &amp;&amp; !!dom.nodeType; &#125;, // 判断是不是html字符串 isHTML: function( html ) &#123; return html.charAt(0) === '&lt;' &amp;&amp; html.charAt(html.length - 1) === '&gt;' &amp;&amp; html.length &gt;= 3; &#125;, // 判断是不是window isWindow: function( win ) &#123; return !!win &amp;&amp; win.window === win; &#125;, // 判断是不是伪数组或数组 isLikeArray: function( likeArray ) &#123; // function &amp; window 返回 false if ( jQuery.isFunction( likeArray ) || jQuery.isWindow( likeArray ) ) &#123; return false; &#125; // 如果likeArray是对象，并有length属性，length属性值为0或者拥有length-1的属性 return !!likeArray &amp;&amp; typeof likeArray === 'object' &amp;&amp; 'length' in likeArray &amp;&amp; ( likeArray.length === 0 || [likeArray.length - 1] in likeArray ); &#125;, // 解析html parseHTML: function( html ) &#123; var tempDiv = document.createElement('div'); tempDiv.innerHTML = html; return tempDiv.children; &#125;, // 封装一个兼容的DOMContentLoaded方法 ready: function( fn ) &#123; // 如果页面已经触发了DOMContentLoaded事件，那么直接执行fn， // 再监听DOMContentLoaded事件已经无用了。 if ( jQuery.fn.isReady ) &#123; return fn(); &#125; // IE9以及现代浏览器使用addEventListener以及DOMContentLoaded事件 if ( document.addEventListener ) &#123; document.addEventListener('DOMContentLoaded', function () &#123; jQuery.fn.isReady = true; fn(); &#125;); &#125; // IE8使用attachEvent以及onreadystatechange事件 else &#123; document.attachEvent('onreadystatechange', function () &#123; if ( document.readyState === 'complete' ) &#123; jQuery.fn.isReady = true; fn(); &#125; &#125;); &#125; &#125;&#125;); 12345678910111213141516171819202122232425262728293031323334353637383940// 构造函数var init = jQuery.prototype.init = function ( selector ) &#123; // 空处理 ==&gt; 直接返回this if ( !selector ) &#123; return this; &#125; // 函数 ==&gt; 添加到DOMContentLoaed事件中 if ( jQuery.isFunction( selector ) ) &#123; jQuery.ready( selector ); &#125; // 字符串 ==&gt; 要么解析为DOM，要么作为选择器获取页面中的DOM else if ( jQuery.isString( selector ) ) &#123; // html片段 if ( jQuery.isHTML( selector ) ) &#123; [].push.apply(this, jQuery.parseHTML( selector )); &#125; // 选择器 else &#123; [].push.apply( this, document.querySelectorAll( selector ) ); &#125; &#125; // dom ==&gt; 直接添加到this中 else if ( jQuery.isDOM( selector ) ) &#123; [].push.call( this, selector ); &#125; // 数组或伪数组 ==&gt; 把每一项都添加到this中 else if ( jQuery.isLikeArray( selector ) ) &#123; [].push.apply( this, selector ); &#125; // 其他 ==&gt; 直接添加到this中 else &#123; [].push.call( this, selector ); &#125;&#125;; 12345678910 // 为了第三方扩展(即jQ插件) init.prototype = jQuery.fn; // 对外暴漏 w.jQuery = w.$ = jQuery; // 解决DOMContentLoaded不触发的问题 $(function () &#123;&#125;);&#125;( window )); 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 // 测试空 console.log($());; console.log($(null)); // 测试函数 $(function () &#123; console.log('函数1'); &#125;); $(function () &#123; console.log('函数2'); &#125;); // 测试hmtl片段 console.log($('&lt;a&gt;11&lt;/a&gt;是&lt;span&gt;阿迪&lt;/span&gt;放&lt;a&gt;22&lt;/a&gt;')); // 测试字符串选择器 console.log($('abc')); console.log($('script')); // 测试dom console.log( $( document.body ) ); // 测试伪数组 console.log( $([1,2]) ); // 每一项分别添加到this身上 console.log( $(&#123; length: 0 &#125;) ); // 每一项分别添加到this身上 console.log( $(&#123; 9: '算数', length: 10 &#125;) ); // 每一项分别添加到this身上 console.log( $(&#123; 5: '不算数', length: 8 &#125;) ); // 直接添加到this身上 console.log( $(&#123; length: 4 &#125;) ); // 直接添加到this身上 console.log( $(window) ); // 直接添加到this身上 // 测试其他 console.log( $(111) ); /* * 存在的瑕疵： * 1、当DOMContentLoaded触发完毕之后，在给他添加事件句柄，不会触发了 * 1、先定义一个变量，用来记录DOMContentLoaded是否触发过 * 2、如果触发过，那么传入ready的函数直接执行。 * * 2、IE8以及之前的版本这样使用有问题 [].push.apply( this, &#123;0:1, length:1&#125; ); * */ setTimeout(function () &#123; $(function () &#123; console.log('传入$的函数'); &#125;); $(function () &#123; console.log('过一会传入$的函数'); &#125;); &#125;, 3000);&lt;/script&gt;","categories":[{"name":"详解","slug":"详解","permalink":"http://ihuzb.huzb.vip/categories/详解/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://ihuzb.huzb.vip/tags/jQuery/"}],"keywords":[{"name":"详解","slug":"详解","permalink":"http://ihuzb.huzb.vip/categories/详解/"}]},{"title":"jQuery中ajax方法的dataType:jsonp跨域原理详解","slug":"跨域详解","date":"2016-10-20T13:16:10.000Z","updated":"2016-10-30T15:48:14.794Z","comments":true,"path":"2016/10/20/跨域详解/","link":"","permalink":"http://ihuzb.huzb.vip/2016/10/20/跨域详解/","excerpt":"jQuery中ajax方法的dataType:jsonp跨域原理详解","text":"jQuery中ajax方法的dataType:jsonp跨域原理详解 a.html1234567891011121314151617'&lt;input type=\"button\" value=\"jsonp跨域原理\" id=\"but\"&gt;'&lt;script&gt; //4.定义一个与参数相同的函数 function getInfo(da) &#123; //7.客户端接收到getInfo(&#123;\"name\":\"hu\",\"age\":15&#125;)这样的参数 //8.浏览器当作js进行解析,最终将json打印到控制台 console.log(da) &#125; document.querySelector(\"#but\").onclick = function () &#123; var script = document.createElement(\"script\") //1.使用script访问不会有跨域问题 //2.现在返回的数据直接被浏览器当作js解析 //3.给服务器发送一个参数,当前提交方式为get方式提交 script.src = \"b.php?name=getInfo&amp;age=15\" document.querySelector(\"body\").appendChild(script) &#125;&lt;/script&gt; b.php123456&lt;?php//5.最终目的是要把这个json格式数据写到客户端//6.获取到之前所定义函数名想同的参数，并将需要响应的json进行拼接，一起响应给服务器端$data=$_GET[\"name\"];echo $data.'(&#123;\"name\":\"hu\",\"age\":15&#125;)';?&gt;","categories":[{"name":"详解","slug":"详解","permalink":"http://ihuzb.huzb.vip/categories/详解/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://ihuzb.huzb.vip/tags/jQuery/"}],"keywords":[{"name":"详解","slug":"详解","permalink":"http://ihuzb.huzb.vip/categories/详解/"}]},{"title":"Canvas第二天","slug":"Canvas02","date":"2016-10-17T12:57:10.000Z","updated":"2016-10-30T15:44:12.944Z","comments":true,"path":"2016/10/17/Canvas02/","link":"","permalink":"http://ihuzb.huzb.vip/2016/10/17/Canvas02/","excerpt":"Canvas 第二天,forEach方法,map方法,画弧，文字API，图像API。","text":"Canvas 第二天,forEach方法,map方法,画弧，文字API，图像API。 forEach ES5提供的用来遍历数组地方法，该方法来自Array.prototype 语法：数组.forEach(function(val,index,arr){}) forEach会自动帮我们遍历数组，每遍历到数组中的一个值 就会调用回调，并且给回掉穿三个参数：遍历到的值，该值的下标，原数组 map map ：ES5提供的用来遍历数组的方法，该方法来自Array.prototype map方法会接收返回值，把返回值组成一个新的数组。 语法：数组.map(function ( val, index, arr ) { return val * 10 }); map会自动帮我们遍历数组，每遍历到数组中的一个值， 就会调用回调，并且给回调传三个参数：遍历到的值，该值的下标，原数组, 然后接收回调的返回值，最终构成新数组返回。 画弧 ctx.arc(圆心x，圆心y，半径，其实弧度，结束弧度，是否逆时针画（可选）)绘制的是弧路径 180°=1π弧度 360°=2π弧度 文字API设置文本样式 ctx.font=语法和css一样。这是文字大小颜色样式等 ctx.textAlign=start、center、end设置文字水平排列方式 ctx.textBaseline=top、middle、bottom、alphabetic、hanging、ideographic设置文字垂直排列方式绘制描边文字 ctx.strockText(&#39;文本&#39;,x,y,(可选：文本最大程度))文字默认中心点在左下角绘制填充文本 ctx.fillText(&#39;文本&#39;,x,y) 图像API ctx.drawImage(图像资源，x，y，裁剪的宽，裁剪的高，图象显示的宽，图像显示的高)绘制图像 var img=new Image()创建了图片节点，内置的image构造函数1234var img=new Image()img.src=\"/image/sdsd.jpg\"img.addEventListener('load',function()&#123;ctx.drawImage(图像资源，x，y，裁剪的宽，裁剪的高，图象显示的宽，图像显示的高)","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://ihuzb.huzb.vip/tags/Canvas/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"毫秒转换成小时分钟秒","slug":"毫秒转换成小时分钟秒","date":"2016-10-17T12:30:10.000Z","updated":"2016-10-30T15:44:12.932Z","comments":true,"path":"2016/10/17/毫秒转换成小时分钟秒/","link":"","permalink":"http://ihuzb.huzb.vip/2016/10/17/毫秒转换成小时分钟秒/","excerpt":"JavaScript实现毫秒转换成小时分钟秒","text":"JavaScript实现毫秒转换成小时分钟秒 使用Date的now方法获取当前毫秒值，再根据相应的公式进行计算123var housr = Math.floor(Date.now() / (1000 * 60 * 60));var minutes = Math.floor(Date.now() % (1000 * 60 * 60) / (1000 * 60));var seconds = Math.floor(Date.now() % (1000 * 60) / 1000);","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"Canvas第一天","slug":"Canvas","date":"2016-10-14T04:55:10.000Z","updated":"2016-10-14T06:57:59.432Z","comments":true,"path":"2016/10/14/Canvas/","link":"","permalink":"http://ihuzb.huzb.vip/2016/10/14/Canvas/","excerpt":"Canvas 第一天,基本属性,非0环绕原则,内置矩形方法。","text":"Canvas 第一天,基本属性,非0环绕原则,内置矩形方法。 Canvas属性设置 &lt;canvas&gt;&lt;/canvas&gt;画布标签 &lt;canvas id=&quot;cvs&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;在标签内设置宽高不会拉伸画布中的图像 var cvs = document.getElementById(&#39;cvs&#39;);获取画布标签 var ctx = cvs.getContext(&#39;2d&#39;);设置画图为2d ctx.strokeStyle设置颜色 ctx.moveTo(10, 10);设置画图起始点 ctx.lineTo(110, 10);设置画图目标点 ctx.stroke();根据当前的路径执行画图 ctx.beginPath()清除当前所有路径，放置再次绘制 ctx.lineWidth=5线宽 ctx.closePath()闭合路径,从当前路径的结束点，到起始点相连 ctx.clearRect(擦出矩形的左上角x轴，擦出矩形的左上角y轴，擦出的宽，擦出的高)清除画布 ctx.fillStyle=css，ctx.fill()填充，这个方法和stroke一样，都是根据当前的路径进行填充 非0环绕原则 作用就是用来判断画布中的那些地方需要填充 真正作用是用来判断哪些居于是被环绕起来的 原理： 随便找一块封闭的区域，然后再区域中随便找一点，向外发一条射线， 然后会继续计数判断，初始值为0 如果射线遇到边，这条边相对于点是逆时针-1，顺时针+1，最终结果非0 那么就认为这块区域是被环绕起来的。 凡是奇数边，围起来的图形区域，都是被环绕起来的，如果调用fill方法，一定会被填充 内置矩形方法 ctx.rect(x,y,w,h)画矩形路径的方法 ctx.strokeRect(x,y,w,h)绘制描边矩形，不会产生任何路径 ctx.fillRect(x,y,w,h)绘制填充矩形，不会产生任何路径 线帽样式 ctx.lineCap=的属性值：butt默认样式,round圆头,square两端各加线宽的一半 交点样式 ctx.lineJoin=的属性值：miter默认样式尖尖的,round四角为圆,bevel四角为斜面 线帽与焦点样式不一致，优先按照焦点样式处理 虚线 获取虚线的绘制规则 ctx.getLineDash()获取虚线的绘制规则 设置虚线的绘制规则 ctx.setLineDash([实线部分的长度，空白部分的长度])设置虚线的绘制规则，如果 传入数组的数量为奇数，那么保存时canvas会自动变为偶数的数量存储 ctx.LineDashOffset=2设置虚线的偏移量","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://ihuzb.huzb.vip/tags/Canvas/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"判断类型","slug":"判断类型","date":"2016-10-12T15:38:10.000Z","updated":"2016-10-30T15:44:12.804Z","comments":true,"path":"2016/10/12/判断类型/","link":"","permalink":"http://ihuzb.huzb.vip/2016/10/12/判断类型/","excerpt":"判断类型。","text":"判断类型。 判断类型1234567891011121314151617function type(data) &#123; if (data !== data) &#123; //若自身不等于自身，那么类型为NaN return \"NaN\" &#125; else if (data === null) &#123; //若等于null，那么类型null return \"null\" &#125; else if (typeof data !== \"function\" &amp;&amp; typeof data !== \"object\") &#123; //若类型不等于函数也不等于对象，那么就是普通数据类型 return typeof data &#125; else &#123; //剩下的其他的就是对象和函数 return (&#123;&#125;).toString.call(data).slice(8, -1) &#125;&#125;//打印结果console.log(type([]));","categories":[{"name":"编程技巧","slug":"编程技巧","permalink":"http://ihuzb.huzb.vip/categories/编程技巧/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"编程技巧","slug":"编程技巧","permalink":"http://ihuzb.huzb.vip/categories/编程技巧/"}]},{"title":"文字溢出使用省略号替代","slug":"文字溢出使用省略号","date":"2016-10-10T11:30:20.000Z","updated":"2016-10-14T06:59:58.566Z","comments":true,"path":"2016/10/10/文字溢出使用省略号/","link":"","permalink":"http://ihuzb.huzb.vip/2016/10/10/文字溢出使用省略号/","excerpt":"文字溢出使用省略号替代的设置方式","text":"文字溢出使用省略号替代的设置方式 需要将以下设置都设置在样式中overflow: hidden;内容溢出后隐藏word-break: break-all;请执行换行text-overflow: ellipsis;多出来的文字用省略号表示，必须与overflow: hidden;一起使用，只针对单行文本-webkit-line-clamp: 2;省略号所在的行数-webkit-box-orient: vertical;垂直display: -webkit-box;伸缩盒子","categories":[{"name":"详解","slug":"详解","permalink":"http://ihuzb.huzb.vip/categories/详解/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ihuzb.huzb.vip/tags/CSS/"}],"keywords":[{"name":"详解","slug":"详解","permalink":"http://ihuzb.huzb.vip/categories/详解/"}]},{"title":"递归求幂性能优化","slug":"递归求幂性能优化","date":"2016-10-05T12:06:01.000Z","updated":"2016-10-30T15:44:12.820Z","comments":true,"path":"2016/10/05/递归求幂性能优化/","link":"","permalink":"http://ihuzb.huzb.vip/2016/10/05/递归求幂性能优化/","excerpt":"递归求幂性能优化","text":"递归求幂性能优化 递归求幂性能优化1234567891011121314151617181920212223242526272829//此优化体现在，第二次执行递归求幂并且所输入的幂数小于前一次所输入的幂数 var qiumi = (function () &#123; //为防止函数使用的变量被污染，将整体放在一个自调函数中 var mi = &#123;&#125;; //创建一个用来存储每次求幂的结果的对象，其内部数据结构是2:[1,2,4,8...] var cunchu = null; //用来存储得到的结果 return function (m, n) &#123; if (mi[m] &amp;&amp; mi[m][n]) &#123; //首先判断对象中mi[m]是否有值，并且有没有需要的数据，若有直接返回数据，若没有继续执行进行计算 return mi[m][n]; &#125;; if (n === 0) &#123; //判断幂若为0，直接返回1 cunchu = 1; //先将数据存储到变量中 &#125; else &#123; cunchu = qiumi(m, n - 1) * m; //先将数据存储到变量中 &#125;; mi[m] = mi[m] ? mi[m] : []; //判断mi[m]是否有值，若没值就将mi[m]变为数组。在第一次运行的时候对象mi[m]没有值，所以要先进行判断 mi[m][n] = cunchu; //将在变量中存储的数据存储到对象中 return cunchu; //将变量中的数据返回 &#125; &#125;)() console.log(qiumi(2, 6));","categories":[{"name":"性能优化技巧","slug":"性能优化技巧","permalink":"http://ihuzb.huzb.vip/categories/性能优化技巧/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"性能优化技巧","slug":"性能优化技巧","permalink":"http://ihuzb.huzb.vip/categories/性能优化技巧/"}]},{"title":"递归求阶乘性能优化","slug":"递归求阶乘性能优化","date":"2016-09-23T14:10:15.000Z","updated":"2016-10-30T15:44:12.969Z","comments":true,"path":"2016/09/23/递归求阶乘性能优化/","link":"","permalink":"http://ihuzb.huzb.vip/2016/09/23/递归求阶乘性能优化/","excerpt":"递归求阶乘性能优化","text":"递归求阶乘性能优化 递归求阶乘性能优化12345678910111213141516171819202122232425262728//此优化体现在，第二次执行递归求阶乘并且所输入的计算位数小于前一次所输入的计算位数 var jiecheng = (function () &#123; //为防止函数使用的变量被污染，将整体放在一个自调函数中 var arr = []; //创建一个用来存储每次求阶乘的结果的数组 var cunchu=null //用来存储得到的结果 return function (a) &#123; if (arr[a]) &#123; //判断数组中有没有需要的数据，若有直接返回数据，若没有继续执行进行计算 return arr[a]; &#125; if (a === 0) &#123; //判断要计算的阶乘个数若为0，直接返回1 cunchu= 1; //先将数据存储到变量中 &#125; else &#123; cunchu=jiecheng(a - 1) * a； //先将数据存储到变量中 &#125; arr[a] = cunchu; //将在变量中存储的数据存储到数组中 return cunchu; //将变量中的数据返回 &#125; &#125;)(); console.log(jiecheng(5)); console.log(jiecheng(5));","categories":[{"name":"性能优化技巧","slug":"性能优化技巧","permalink":"http://ihuzb.huzb.vip/categories/性能优化技巧/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"性能优化技巧","slug":"性能优化技巧","permalink":"http://ihuzb.huzb.vip/categories/性能优化技巧/"}]},{"title":"使用改变this指向的方式获取DOM元素并改变颜色","slug":"改变this指向","date":"2016-09-21T14:16:06.000Z","updated":"2016-10-30T15:44:12.873Z","comments":true,"path":"2016/09/21/改变this指向/","link":"","permalink":"http://ihuzb.huzb.vip/2016/09/21/改变this指向/","excerpt":"使用改变this指向的方式获取DOM元素并改变颜色","text":"使用改变this指向的方式获取DOM元素并改变颜色 使用改变this指向的方式获取DOM元素并改变颜色123456789101112var arr = [], t = document.getElementsByTagName.bind(document)//定义空数组，用来存储获取的DOM元素。定义t，使用Function.prototype中的bind属性改变this指向，使其指向document(因为所有的DOM元素都在document中)var lis = t(\"li\")//使用定义的t函数获取所有的li标签var di = t(\"div\")arr.push.apply(arr, lis)//所获取到的li标签组成一个数组，需要将数组平铺到arr数组中，所以要使用apply属性arr.push.apply(arr, di)for (var i = 0, len = arr.length; i &lt; len; i++) &#123;//遍历选中的所有标签，改变其背景色 arr[i].style.background = \"red\"&#125; call 和 apply方法，会马上执行函数； bind不会马上执行，它返回函数的一个copy版本，供以后想执行的时候再执行。 可查看学习资料的博客简述语法:http://ihuzb.huzb.vip/2016/09/15/面向对象%20第七天/","categories":[{"name":"编程技巧","slug":"编程技巧","permalink":"http://ihuzb.huzb.vip/categories/编程技巧/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"编程技巧","slug":"编程技巧","permalink":"http://ihuzb.huzb.vip/categories/编程技巧/"}]},{"title":"面向对象 第七天","slug":"面向对象 第七天","date":"2016-09-15T14:01:15.000Z","updated":"2016-10-30T15:44:12.993Z","comments":true,"path":"2016/09/15/面向对象 第七天/","link":"","permalink":"http://ihuzb.huzb.vip/2016/09/15/面向对象 第七天/","excerpt":"面向对象第七天，严格模式，递归。","text":"面向对象第七天，严格模式，递归。 严格模式 1.全局模式 在代码最前面添加一句话：&#39;use strict&#39; 严格模式下，必须通过var定义变量 一个对象不能存在重复的属性名，会报错 函数形参的名字不能重复，会报错 eval会产生单独的作用域，避免了全局变量的产生 无法在非函数的代码块中声明函数，var a=function(){}，可以使用 严格模式下禁止使用with语句 严格模式下，函数的caller(返回调用的函数的函数)属性禁止使用 严格模式下，atguments的callee(返回函数自身)属性禁止使用 2.局部模式 在函数的第一行写&#39;use strict&#39; 构造函数返回值 如果函数作为构造器使用，没有return语句，那么忽略，得到实例 如果函数作为构造器使用，return基本数据类型，那么忽略，得到实例 如果函数作为构造器使用，return对象类型的数据，那么覆盖实例，得到return的对象 get/set读写器 是ES5新增的一种语法，市面上称他们为读写器123456789101112var a=1;var obj=&#123; set val(par)&#123; a=par &#125;, get val()&#123; return a; &#125;&#125;obj.val=10console.log(obj.val)//对于使用者来说，操作的obj的val属性，实际上val是两个方法，最终操作的是a变量。 递归 函数自己调用自己，或者间接调用自己，称之为递归。 递归特点： 1.必须要有临界点（临界条件，return语句） 2.把药解决的问题尽量细化如果发现解决问题是用到了之前的成果，并且有规律就可以把这个规律转换成递归的形式 call,apply,bind 这个三个方法都是来自于Function.prototype上，所以所有的函数都可以使用，都有一个共同点，可以指定函数执行时内部this的指向call 语法：函数名.call(this指向，实参1，实参2…) apply语法1：函数名.call(this指向，[实参1，实参2…])语法2：函数名.call(this指向，{实参1，实参2， length：2}) bind语法：var fn=函数名.bind(this指向，要绑定的实参1，要绑定的实参2…) 严格模式严格模式分为全局模式和局部模式 12//全局模式，就是在全局代码的最前面写这句话'use strict' 1234//局部模式，就是在函数代码的最前面写这句话function fn()&#123;'use strict'&#125; 严格模式禁止使用 必须通过var定义变量对象中不能存在重复的属性名函数中不能存在重复的形参名eval会产生单独的作用域，避免了全局变量的产生。无法在非函数的代码块中声明函数了禁止使用with语句禁止使用函数的caller属性禁止使用arguments的callee属性","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"判断滚动条到达底部","slug":"设置滚动条一直在底部","date":"2016-09-10T12:11:20.000Z","updated":"2016-10-30T15:44:12.870Z","comments":true,"path":"2016/09/10/设置滚动条一直在底部/","link":"","permalink":"http://ihuzb.huzb.vip/2016/09/10/设置滚动条一直在底部/","excerpt":"判断滚动条到达底部","text":"判断滚动条到达底部 使用之前记得导入jq包12345678$(window).scroll(function () &#123; if ($(document).scrollTop() + $(window).height() &gt;= $(document).height()) &#123; qing()//需要执行的函数 &#125;&#125;)$(document).scrollTop()：向下滚动滚动条的移动的距离$(window).height()：当前显示窗口的高度，滚动不会影响$(document).height()：整个文档页面的整体高度","categories":[{"name":"详解","slug":"详解","permalink":"http://ihuzb.huzb.vip/categories/详解/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://ihuzb.huzb.vip/tags/jQuery/"}],"keywords":[{"name":"详解","slug":"详解","permalink":"http://ihuzb.huzb.vip/categories/详解/"}]},{"title":"面向对象 第六天","slug":"面向对象 第六天","date":"2016-08-18T12:11:20.000Z","updated":"2016-10-14T06:54:57.142Z","comments":true,"path":"2016/08/18/面向对象 第六天/","link":"","permalink":"http://ihuzb.huzb.vip/2016/08/18/面向对象 第六天/","excerpt":"面向对象学习第六天，tyopof，匿名函数与闭包，自调函数的作用，函数的四种调用模式。","text":"面向对象学习第六天，tyopof，匿名函数与闭包，自调函数的作用，函数的四种调用模式。 tyopof类型判断 typeof运算结果只有如下几种值 object,string,number,boolean,function,undefiend 匿名函数与闭包 匿名函数是没有名字的函数 闭包是函数内的函数 自调函数是马上执行的函数 构造函数是用来创建实例的函数 方法是添加到对象身上的函数 setTimeout 传入setTimeout的回调函数是异步执行的 ,不是随着代码的顺序执行的 从上往下把其他的执行完后，再执行setTimeout 自调函数的作用 防止全局变量污染： 过多的全局变量，极易出现冲突于混淆 提供一个新的区域放置全局变量污染简称沙箱模式或命名空间 自调传入window，一般有两个作用： 1.提升全局变量的查找时间 2.有助于代码的压缩 函数的四种调用模式 函数调用模式 直接函数名()调用，内部this指向全局对象（window） 方法调用模式 对象.函数名()或者对象[函数名]()调用，内部this指向方法所属的对象 构造器调用模式 new 函数名()或者new 对象.函数名() 或者 new 对象[函数名]()，内部this指向新创建的实例。 间接调用模式 函数名.call()或者对象.函数名.call() 或者 new 对象[函数名].call()，内部this指向自定义的对象,如果传空、null、undefined，那么this指向全局对象window call和apply是来自Function.prototype里面的两个方法 这两个方法有一个共同点，就可以指定函数执行时内部的this指向 语法:函数名.call(指定函数执行时的this指向) 语法:函数名.apply(指定函数执行时的this指向) 通过fn调用call方法，call方法内部会反过来调用fn，并且指定fn执行时内部的this为数组 call和apply的具体语法 call语法： 函数名.call(自定义的this指向，实参1，实参2，实参3…) 第一个参数只是为了指定函数执行时this的指向，并不会作为参数传入进去 apply语法： 函数名.apply(自定义的this指向，[实参1，实参2，实参3…]) 第一个参数只是为了指定函数执行时this的指向，并不会作为参数传入进去，第二个参数要求是数组或伪数组，apply会自动把数组中的内容平铺后传入到函数中。 tostring方法 Object.prototype.toString()[方法调用模式] 执行时根据内部的this，返回一个这样的字符串：‘[object this的类型]’ 函数的四种调用模式 函数中的this是动态变化的，不同的调用方式，this指向不同 说明函数中的this和调用有关，和定义无关。 fn(); 函数调用模式，this指向window new Fn(); 构造器调用模式，this指向创建出的实例 Fn.apply(fn)；间接调用模式，this指向fn Function方法详解 Function.prototype自身是一个函数，并且是唯一一个没有prototype属性的函数 Function.prototype上定义了如下属性与方法： apply:可以改变函数执行时内部this指向 arguments:之前还是函数的属性，现在被废弃 bind:返回一个函数的copy版本，并且可以指定该函数执行时内部this call:可以改变函数执行时内部this指向 caller:返回调用该函数的函数 constructor:对应的构造函数 length:函数形参的个数 name:函数的名字 toString:把函数体作为字符打印 __proto__:Function.prototype所继承的对象，即Object.prototype区别 Object.prototypr call和apply方法，会马上执行函数 bind不会马上执行，它返回函数的一个copy版本，供以后想执行的时候在执行bind ES5提供的方法，ie9以及以前无法使用 语法:函数名.bind（指定返回函数执行似的this指向，要绑定的实参1，要绑定的实参1。。。） 返回值：函数的copy版本 如果以后前两个参数一直是10，就可以通过bind绑定死，以后就不用传了","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"前端面试题集锦(html5,css3)01","slug":"前端面试题集锦(html5,css3)01","date":"2016-08-10T12:15:10.000Z","updated":"2016-10-30T15:44:12.858Z","comments":true,"path":"2016/08/10/前端面试题集锦(html5,css3)01/","link":"","permalink":"http://ihuzb.huzb.vip/2016/08/10/前端面试题集锦(html5,css3)01/","excerpt":"前端面试题集锦(html5,css3)","text":"前端面试题集锦(html5,css3) 1.主流浏览器和使用的内核分别是什么 IE:trident内核 Firefox:gecko内核 Safari:webkit内核(苹果浏览器) Opera:以前是presto内核，改为Chrome的Blink内核 Chrome:Blink(基于webkit,Google与Opera Software共同开发) 2.每个HTML开头都有个很重要的东西是什么 &lt;!DOCTYPE&gt;声明位于文档中的最前面的位置，处于标签之前。 此标签告知浏览器文档使用那种HTML或XHTML规范来解析页面。 注：XHTML的编写规范较HTML更加严格 3.div+css的布局较table布局有什么优点？ 页面加载速度更快、结构清晰、页面显示简洁 表现与结构相分离 易于优化(seo)搜索引擎更友好，排名更容易靠前 4.img的alt与title有何异同？strong与em的异同？ alt：是图片加载失败时，在页面上显示的代替文字 title：是鼠标放上面时显示的文字 strong：粗体强调标签，强调，表示内容的重要性 em：斜体强调标签，更强烈强调，表示内容的强调点 5.渐进增强和优雅降级之间的不同？ 渐进增强：(progressive enhancement)针对低版本浏览器进行构建页面，保证最基本的功能，然后在针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级：(graceful degradation)一开始就构建完整的功能，然后在针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。优雅降级意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 6.为什么利用多个域名来存储网站资源会更有效? CDN缓存更方便，用户在浏览网站的时候，CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求 突破浏览器并发显示，不同域可以提高请求资源并发 跨域节约cookie带宽，尤其是上行带宽，一般比下行要慢 节约主域名连接数，从而提高客户端网络带宽的利用率，优化页面响应 注：关于多域名，也不是越多越好，虽然服务器可以做泛解释，浏览器做dns解释也是耗时间的，而且太多域名，如果要走https的话，还有要多买证书和部署的问题 7.css的content属性有什么作用和应用？ css的content属性专门应用在before/after伪元素上，用来插入生成内容。 用法： 1.添加任意的字符串 2.使用UTF-8特殊字符 3.使用url()可以载入外部资源，主要是一些图标和图片，如果资源不可以显示，有的浏览器会忽略它，有的会显示替代文本 4.HTML元素属性 5.利用伪类清除浮动，（content:”.”）after伪元素通过content在元素的后面生成了内容为一个点的块级元素，再利用clear:both清除浮动 8.css计数器，通过content属性实现css计数器？ 初始化计数器： 123Ol &#123; counter-reset:slideNum;// 重置计数器，让它归零，并给它指定一个名称：slideNum &#125; 计数器自增： 123ol li &#123; counter-increment: slideNum;//计数器自增，每遇到一个符合条件li元素，counter-increment就会被调用一次，计数就是增加1。&#125; 显示计数器： 1234ol li:before &#123; content: counter(slideNum,upper-roman) “. ”;&#125;//指定以罗马数字显示`counters():会嵌套。语法：counters(计数器名称, 嵌套时拼接字符串[, 可选的显示风格])` 123ol li:before &#123; content: counters(slideNum,”.”);//使用点号分割&#125; 9.谈一下对网页标准和标准制定机构重要性的理解？ 网页标准和标准制定机构都是为了能让web发展的更‘健康’ 开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做 也不会因为滥用代码导致各种BUG、安全问题，最终提高网站易用性。 10.请描述一下cookies，sessionStorage和loaclStorage的区别？ sessionStorage用于本地存储一个会话（session）中的数据，这些数据只会在同一个会话中的页面才能访问并且放会话结束后数据也随之销毁，因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储 loaclStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 coolies的大小数显，并且每次请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie需要指定作用域，不可以跨域调用。 11.简述一下src与href的区别？ sec： sec用于替换当前元素，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置 在请求src资源是会将其指向的资源下载并应用到文档中，例如js脚本，img图片和frame等元素 注：当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内，这也是为什么将js脚本放在底部而不是头部。 href： href用于在当前文档和引用资源之间确立联系。 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接 下载资源并且不会停止对当前文档的处理，这就是为什么建议使用link方式来加载css，而不是使用@import方式 12.网页制作会用到的图片格式有哪些？ png-8,png-24,jpeg,gif,svg,Webp Webp:谷歌开发的一种旨在加快图片加载速度的图片格式，图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间 在质量相同情况下，Webp格式图像的体积要比JPEG格式图像小40%","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://ihuzb.huzb.vip/categories/面试资料/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ihuzb.huzb.vip/tags/CSS/"},{"name":"HTML5","slug":"HTML5","permalink":"http://ihuzb.huzb.vip/tags/HTML5/"}],"keywords":[{"name":"面试资料","slug":"面试资料","permalink":"http://ihuzb.huzb.vip/categories/面试资料/"}]},{"title":"面向对象 第五天","slug":"面向对象 第五天","date":"2016-08-05T11:11:20.000Z","updated":"2016-10-14T06:54:02.519Z","comments":true,"path":"2016/08/05/面向对象 第五天/","link":"","permalink":"http://ihuzb.huzb.vip/2016/08/05/面向对象 第五天/","excerpt":"面向对象学习第五天，作用域链，闭包，阻止变量释放。","text":"面向对象学习第五天，作用域链，闭包，阻止变量释放。 作用域链 作用域链：变量所有的有效区域(运行环境)，统称作用域链 环境：一个东西所依赖的就是环境，代码执行时所依赖的环境 执行环境：代码执行时所依赖的环境，函数被调用一次就会产生一个新的环境 函数多次调用返回的数值是同一个 函数多次调用返回的对象不是同一个，每次都是不一样的的对象，不一样的地址闭包广义闭包 可以访问非自身变量的函数， 从这种角度上说，所有函数都是闭包 使用了非自身变量的函数狭义闭包 可以访问非自身局部变量的函数，从这种角度来说，函数内的函数就是闭包。 使用了非自身局部变量的函数 闭包特点：利用闭包，可以在任何地方操作一个局部变量，可以在延长局部变量的生命周期变量的生命周期 变量的生命周期：一个变量从定义开始，到销毁结束，中间存活的过程就叫做变量的生命周期 全局变量的生命周期：从定义开始，到页面被卸载结束，中间存活的过程就叫做全局变量的生命周期 局部变量的生命周期：一般情况下从定义开始，到函数执行完毕结束，就是局部变量的生命周期，但是有的情况闭包引用了这个变量，那么这个变量的生命周期和闭包一样长。 因为f变量一直存储着一个闭包函数，js解析引擎无法得知将来是否还有调用f函数，所以f函数不会被释放，那么对应的a局部变量也不会被释放，这样就会造成内存浪费，如果将来f函数不会在使用了，最好手动给f赋值为null阻止变量释放 -如果return一个基本数据类型不会阻止变量释放 - 如果想阻止变量的释放，必须借助闭包 如果return一个对象会阻止变量释放主导变量的控制权 私有属性 操作私有属性目的：防止其他地方对该属性进行随意修改的隐患 保存状态 变量的状态：意指变量不同时期所存储的值","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"面向对象 第四天","slug":"面向对象 第四天","date":"2016-07-30T12:13:20.000Z","updated":"2016-10-30T15:44:12.833Z","comments":true,"path":"2016/07/30/面向对象 第四天/","link":"","permalink":"http://ihuzb.huzb.vip/2016/07/30/面向对象 第四天/","excerpt":"面向对象学习第四天，函数基本属性，作用域与预解析，变量声明与函数声明。","text":"面向对象学习第四天，函数基本属性，作用域与预解析，变量声明与函数声明。 面向对象的三大特征- 封装 - js中的封装就是把一堆相关性的变量和函数组织到一起 - 继承 - js中的继承就是原型 - 多态 - js中的多态可以理解是对象的动态变化 其他语法补充 for in能够 for in可以遍历出一个对象继承的属性（必须是可枚举的） 静态成员和实例成员 静态成员（类成员）：添加给类（构造函数）自己的的属性和方法，称之为静态成员 特点：不需要创建实例，即可通过类调用 实例成员：添加给实例的属性和方法，称之为实例成员 function person（name，age）{这是添加给将来的实例的，所以叫实例成员this.name=namethis.age=age}这是添加给类自己的，所以这是静态成员person.max_age=200添加到原型中的属性与方法，本意是让实例使用的，所以也称之为实例成员person.prototype.run=function(){console.log(“run”)} 在jq中 $.ajax这里面的ajax方法就是静态成员 $(“div”).css()，这里面的css方法就是实例成员 什么情况下会使用静态成员 1.如果一些属性和类的关联性比较大，那么可以考虑作为静态成员存在 2.如果一些方法具有通用性，那么可以考虑作为静态方法存在 Object原型上的方法 hasOwnProperty 作用：用来判断一个对象是否自己（不包含继承的)含有某个属性 语法：对象.hasOwnProperty(要判断的属性名) 返回值：boolean isPrototypeOf 作用：判断一个对象是不是另一个对象的原型对象 语法：被判断对象.isPrototypeOf（对象） 返回值：boolean propertyIsEnumerable 作用：用来判断一个对象是否自己（不包含继承的)含有某个属性，并且还要判断这个属性是不是可枚举的（可遍历的），这个方法是一个双重判断，通常称这个方法为hasOwnProperty的加强版。 语法：对象.propertyIsEnumerable(要判断的属性名) 返回值：boolean toString 作用：根据方法执行时内部的this指向，返回一个类似于这样的字符串：’[object this对象的类型名称]’ 为了让toString方法执行时，内部的this指向Math，所以吧这个方法先添加到了Math自身，然后通过Math调用，这样toString执行时，内部的this就指向了Math 只能判断内置对象，自定义构造函数创建的对象统一返回[‘Object Object’] 函数默认的原型对象类型 很多地方认为构造函数默认的显示原型对象的类型是构造函数的名字 即Person.prototype是Person类型的对象 依据Boolean，String，Number，Array，Object这几个对象的peototype他们的类型就是构造函数的名字 函数的几个属性 arhuments：代表实参的伪数组对象，也就是实参，之前是fn的属性，但是被废除了，arguments已经是关键字了，可以直接使用，这是推荐的使用方法 caller：返回调用该函数的函数 console.dir(fn)：查看fn中的属性 length：形参的个数 name： 函数的名字 arguments有一个callee属性，该函数返回被调用的函数，callee就是返回函数自身 length属性12345678910function add(a, b) &#123; if ( arguments.length !== add.length ) &#123; throw '参数个数不符！'; &#125; console.log(a + b); &#125; add(10,20,50); add(1); arguments.length:实参个数 add.length:形参个数 in/delete运算符 in运算符：判断一个对象能否使用某个属性 语法： ‘属性名’ in 对象 返回值：boolean delete运算符：删除对象的属性 语法：delete 对象.属性名 或 delete obj[2] Function的使用 通过Function创建一个空函数 var fn=new Function var add=new Function(name1,name2,functionBody) 前面可以定义任意数量的形参，最后以恶参数代表函数的代码体 注意：这些参数必须是字符串的形式 返回值：一个新创建的函数实例 如果使用Function创建函数，很繁琐，一般不会采纳，但是这种方式有一个亮点，就是会把字符串当多代码执行 自变量方式 function add(a,d){console.log(a+b)} eval的使用 eval可以直接把字符串当做代码执行。 eval(‘alert(12313213)’) JSON数据格式==&gt;’{“name”:”李四”}’ 为了方便操作JSON数据，ES5提供了JSON对象，里面有两种方法 JSON.parse:用来把JSON数据转换为js对象 var JSONS=’{“name”:”李四”}’ console.log(JSON.parse(JSONS)) JSON.stringfy:用来把js’对象转换为JSON对象 var obj={value:100,val:320} console.log(JSON.stringify(obj)) 在ie8之前，可以用过eval或者Function解析JSON数据 代码块 就是一对大括号，里面可以写任意代码 如果想要js把大括号当做对象解析，那么需要把大括号放入表达式中使用。 直接使用大括号，就是代码块 { var a = 1; console.log(a); } 放入表达式中，就是对象 var a = {}; 作用域与预解析预解析 预解析概念：在代码整体执行之前，先解析一部分，预解析之后，代码会从上往下依次整体执行，但是预解析执行过的代码不会重复执行 js预解析干了什么事：js中预解析会把声明部分的代码提升执行。 声明分为两部分： 1.变量声明 什么是变量声明：使用var关键字自定义的变量，被称为变量声明 var a=1;其中var a是声明部分 var b,c,d;这里的语句整体都是声明部分 var e,f=j=2,p;其中var e,f,p是声明部分 特点：变量声明提升的特点是，在声明变量的前面，可以使用这个变量console.log(a) var a=10 console.log(a) /****************/ 预解析事执行的代码： var a 预解析之后执行的代码 console.log(a) a=10 console.log(a) 2.函数声明 什么事函数声明：通过function关键字声明的函数 函数声明的特点：在函数声明的前面，可以调用这个函数，函数声明可以提前调用 定义函数的方式： 1.函数声明式 1.函数声明式定义的特征 以function关键字开头定义的函数，并且定义在全局，要么直接嵌套在另一个函数内，这种形式定义的函数就是函数声明式 2.函数声明是定义的函数其它特征 会被预解析 函数必须有名字 function fn(){} 2.函数表达式 1.函数表达式定义的特征 不是以function关键字开头定义的函数，或者函数嵌套在非函数的代码块中，都是函数表达式。 var f=function(){} (function(){})() 在非函数的代码块中定义的函数是函数表达式 {function fn() {}} !function () {}() fn(function () {}) 2.函数表达式的其他特征 不会被预解析 函数名字可有可无 函数的名字只能在函数内部使用 预解析中的疑难杂症 1.变量重名 预解析时如果遇到重复的变量声明，那么忽略 2.函数重名 预解析如果遇到重复的函数声明，使用最后一个函数 3.函数与变量重名 预解析是如果变量与函数重名的情况，保留函数 凡是遇到重名的变量声明，那么忽略 凡是遇到重名的函数声明，当前的函数覆盖之前的 4.函数声明定义在代码块中 一个函数声明式的语法，写在非函数的代码块中，理论上这是函数表达式 但是对于这种函数，浏览器会预解析他的名字 { // 这是函数表达式 function fn() { }} 5.函数执行时内部也存在预解析 形参一定是在代码整体执行之前复得值 6.函数执行时形参赋值的顺序 如果是先复制，后预解析，预解析的函数就覆盖传入的函数， 如果是先预解析，后给形参赋值，传入的函数就覆盖预解析的函数， 作用域 作用域：就是变量的有效范围 如何检测一个变量的作用域： 在指定的区域内使用这个变量，如果未报错说明这个变量的作用域包含此区域 全局变量 在任何地方都可以使用的变量称之为全局变量 如何定义全局变量：在函数外定义的变量都是全局变量 局部变量 在某些地方使用的变量称为局部变量 如何定义局部变量：在函数内声明的变量都是局部变量 全局变量和局部变量就是通过作用域的大小来对变量进行的种类划分 函数作用域：只有函数能够划分变量的作用域，这种作用域的规则就叫函数作用域。 块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫做块级作用域。 在ES6之前，只有函数可以划分变量的作用域，所以在函数的外面无法访问函数内的变量 在ES6之前，没有块级作用域的概念，所以在代码块的外面可以访问代码块内的变量 ES6，对块级作用域做了支持，新增了两种定义变量的方式：let不会预解析（使块级作用域生效），const设置为常量 常量：永远不会变化的量，和变量相反（const）设置为常量 词法作用域（静态作用域）：如果在函数内访问一个变量，优先找局部变量和形参，若没找到去定义该函数的环境中查找，直到全局位置 块级作用域 函数作用域 词法作用域之间的联系 1.块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域 2.词法作用域描述的是变量的查找规则 关系： 1.块级作用域包含函数作用域 2.词法作用域与块级作用域&amp;函数作用域没有任何关系 3.他们从两个角度描述的作用域规则，ES6之前js采用的是函数作用域+词法作用域 动态作用域：如果在函数内访问一个变量，优先找局部变量和形参，如果没有找到，去调用该函数的环境中查找","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"CSS line-height行高详解","slug":"CSS 行高详解","date":"2016-07-25T13:12:20.000Z","updated":"2016-11-01T15:58:55.937Z","comments":true,"path":"2016/07/25/CSS 行高详解/","link":"","permalink":"http://ihuzb.huzb.vip/2016/07/25/CSS 行高详解/","excerpt":"CSS line-height行高三种设置方式详解。","text":"CSS line-height行高三种设置方式详解。 line-height:2 设置为数值时，父盒子设置了行高，子盒子行高以自身字号为参考 如：父盒子字号为10px，那么父盒子行高20px，子盒子字号20px，那么子盒子行高40px line-height:120% 设置为百分比时，父盒子设置了行高，子盒子行高以父盒子字号为参考 如：父盒子字号为10px，那么父盒子行高10*120%=12px，那么子盒子继承父盒子行高为12px line-height:20px 设置像素时，只会对此元素有效果，不会继承","categories":[{"name":"详解","slug":"详解","permalink":"http://ihuzb.huzb.vip/categories/详解/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ihuzb.huzb.vip/tags/CSS/"}],"keywords":[{"name":"详解","slug":"详解","permalink":"http://ihuzb.huzb.vip/categories/详解/"}]},{"title":"面向对象 第三天","slug":"面向对象 第三天","date":"2016-07-15T11:15:06.000Z","updated":"2016-10-14T06:52:20.225Z","comments":true,"path":"2016/07/15/面向对象 第三天/","link":"","permalink":"http://ihuzb.huzb.vip/2016/07/15/面向对象 第三天/","excerpt":"面向对象学习第三天，原型终点，原型链，instanceof运算符。","text":"面向对象学习第三天，原型终点，原型链，instanceof运算符。 寻找原型继承的终点 Person（自己定义的构造函数）的显示原型对象，所继承的对象为Object.prototype 实例化对象继承结构 xiaohong==&gt;Person.prototype.==&gt;Object.prototype==&gt;null 创建的对象继承结构 obj==&gt;Object.prototype==&gt;null 数组继承结构 obj==&gt;Array.prototype==&gt;Object.prototype==&gt;null Math继承结构 Math==&gt;Object.prototype==&gt;null 查看继承方法 1.proto 2.content 继承的规律 1.谁的实例，这个实例就继承谁的peototype 2.所有对象继承的终点都是Object.prototype 3.所有函数默认的显示原型，都继承Object.prototype 4.所有的函数，都继承Function.prototype 测试是否都继承了Object.prototype 所有对象都可以使用Object.prototype 原型链 一个对象继承的所有对象，称之为这个对象的原型对象 上面那个的，原型对象，指的是对象所继承的对象 原型链概念: 一个对象继承的所有对象称之为这个对象的原型链 这是一个描述对象继承结构比较形象的单词 函数的原型链 fn==&gt;Function.prototypr==&gt;Object.prototype==&gt;null 所有函数.prototype都继承Object.prototype，Object.prototype除外，因为他自己就是终点 对象包含很多种类型，函数只是其中一种 函数是对象的一种，也就是说对象包含函数，还包含数组，日期等函数类型的对象 在js中，函数比较特殊，他们都是function类型的对象 但是这些函数可以派生出属于自己的类型 例如： 一个自定义的函数，假设名叫fn，fn自身是Function类型 但是通过new fn创建出来的所有实例都是fn类型 ECMAScript内置的函数类型的对象 String Number Boolan RegExp Function Obkect Array Error Date 上述9大内置构造函数的原型链结构： 9大构造函数==&gt;Function.prototype==&gt;Object.prototype==&gt;null ECMAScript内置的非函数类型的对象 Math Math的原型链结构: Math==&gt;Object.prototype==&gt;null instanceof运算符 instanceof运算符本意用来判断一个对象，是不是另一个构造函数的实例 instanceof运算符运算规则：判断左边对象的原型链结构中，是否存在右边构造函数的显示原型 语法：对象 instanceof 构造函数 返回值：boolean","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"面向对象 第二天","slug":"面向对象 第二天 ","date":"2016-07-08T15:26:57.000Z","updated":"2016-10-30T15:44:12.916Z","comments":true,"path":"2016/07/08/面向对象 第二天 /","link":"","permalink":"http://ihuzb.huzb.vip/2016/07/08/面向对象 第二天 /","excerpt":"面向对象学习第二天，继承，原型，成员类型。","text":"面向对象学习第二天，继承，原型，成员类型。 知识复习1.面向对象概念 1.利用对象解决问题 2.面向对象讲解的就是，凡事不用自己亲历亲为 3.面向对象离不开面向过程，相当于对面想过程的封装 4.面向对象一般应用与大型软件开发，使用了面向对象开发的大型软件就像是使用Xmind进行组织一样2.工厂函数 对创建对象的过程进行了封装 工厂函数的返回值是一个对象，工厂函数就是调用 如果一个函数调用后，返回值是一个对象，就可以认为他是一个工厂函数3.构造函数 如果一个用来配合new关键字创建对象，那么就可以称呼这个函数为构造函数4.构造函数与普通函数的关系 构造函数与普通函数无异，本身就是一个东西5.类 对一些具有相同特征与特性的对象的抽象描述 在ES6之前，可以把构造函数看作是类6.实例 通过构造函数创建出来的对象就叫做实例 注:在口头描述上，实例指的是直系后代（在编程语言中，实例也指子孙后代）7.实例的类型 实例的类型就是构造函数的名字8.原型&amp;原型的作用 概念：原型是js提供的一个实现继承的解决方案 作用：原型就是为了让实例共享一些属性和方法，达到节省内存以及复用代码的目的9. prototype 所有的函数默认都含有这个属性 作用：通过函数new出来的实例，都会继承这个属所指向的对象 本质：prototype就是为了引导实例的__proto__属性值10.__proto__ 所有的对象都含有这个属性 访问一个对象的属性时，如果对象自身没有，就会去__proto__指向的对象中去查找11.new构造函数自动执行的4个步骤 1.new会自动创建一个新对象（本质上就是开拼一块内存空间） 2.给新对象添加一个__proto__属性，该属性的值为(!当前!)构造函数prototypr属性的值 3.利用新对象调用构造函数（那么构造函数内的this就指向了新对象） 4.返回新对象的地址12.属性查找位置 首先找自身，自身没有，顺着__proto__属性查找指定的对象 这对象没有，继续顺着__proto__查找 直到终点 继承的概念 一个对象可以使用本不属于自己的东西 原型具有继承的特性1.继承的方式 默认的原型继承 原型覆写 覆写之后加属性 编程技巧 对象与对象之间的继承 1.obj2可以访问obj中的属性 1234var o = &#123;val: 1, age: 20&#125;var o2 = &#123;name: \"lala\"&#125; o2.__proto__ = o console.log(o2.val); 2.混入只是个编程技巧，严格说不是继承 123456var o = &#123;val: 1, age: 20&#125;var o2 = &#123;name: \"lala\"&#125;for ( var key in o) &#123; o2[key] = o[key] &#125; console.log(o2) 内置的属性不可枚举 就是可被遍历的就叫枚举 不可枚举就是浏览器内置的属性，无法使用for in遍历出 copy继承的优势 不会修改构造函数原生的原型对象 copy继承的注意事项 实现copy继承所需的函数名没有硬性要求 乱使用会造成内存资源浪费 通常都是配合原型来使用的（对原型进行扩展） Object.create Object是内置的一个构造函数 在Object身上有很多方法 其中有一个create方法，可以实现继承 语法： Object.create（被继承的对象）； 返回值：返回一个新对象，新对象继承传入到create方法的对象 作用： 创建一个新对象，并且指定新对象指定继承的对象 小结 继承： 一个对象可以使用另一个对象的东西，叫做继承 一个对象可以使用本不属于自己的东西，叫做继承 js中的原型就是对继承特性的实现 继承本质： 为代码节省复用 继承方式1-默认原型继承123function Fn()&#123;&#125;Fn.prototype.value=100var fn=new Fn() 继承方式2-覆写结构函数的显示原型12345function Fn()&#123;&#125;Fn.prototype=&#123;value:100&#125;var fn=new Fn() 继承方式3-给显示原型混入属性123456789101112function extend(o1,o2)&#123;for(var key in o2)&#123;o1[key]=o2[key]&#125;&#125;var obj = &#123; add: function (a,b) &#123; console.log(a+b) &#125; &#125;function Fn() &#123;&#125;extend(Fn.prototype, obj);extend(Fn.prototype, &#123; value: 100&#125;);var fn = new Fn(); 继承方式4-Object.create12var obj = &#123; value: 100 &#125;var newObj = Object.create(obj); 继承方式5-借用Object.create方法覆写显示模型1234var obj = &#123; value: 100 &#125;function Fn() &#123;&#125;Fn.prototype = Object.create(obj);var fn = new Fn(); 继承方式6-复合式原型继承12345function PrFn() &#123;&#125;PrFn.prototype.value = 100;function Fn() &#123;&#125;Fn.prototype = new PrFn()var fn = new Fn(); 原型组合式 复用Animal构造函数里的代码解决思路： 1.Animal里面有一些this.XX=XX的代码 2.如果，我能够让Animal里面的this指向Person的实例 3.那么Animal里面的代码含义就变成了给Person的实例添加xx属性 把Anmal函数作为属性添加到Person实例本身 然后通过Person实例调用Animal函数，那么A执行时里面的this就指向了Person实例 探索js对象内部继承的秘密 对象的原型对象一定是有终点的 静态成员与实例成员 添加给实例的属性或方法，是实例成员 添加给类自己的属性或方法，是类成员 实例不可以访问静态成员 构造函数不能直接访问实例成员 静态成员只能有构造函数自己使用（实例访问实例成员） 构造函数内添加的实例成员，只有实例成员能够访问（类成员访问类成员）12345function Person(name,age)&#123;这里的name和age属性，应为将来要添加到实例身上，称为实例成员（实例属性）this.name=namethis.age=age&#125; 12直接添加到类上的属性与方法叫静态成员，或者类Person.maxAge=200 特列： 123456789101112function Person(name,age)&#123;this.name=namethis.age=age&#125;//类原型上的属性与方法，本以上是提供给实例使用的//所以这里的属性与方法可以认为是实例成员Person.prototype.run=function()&#123;console.log(\"sds\")//原型对象里面的成员，构造函数不可以访问//原型对象里面的成员，原型对象自己可以访问//原型对象里面的成员，实例可以访问&#125; 动态作用域：如果在函数内访问一个变量，优先找局部变量和形参，如果没有找到，去调用该函数的环境中查找","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]},{"title":"面向对象 第一天","slug":"面向对象 第一天 ","date":"2016-07-01T14:05:57.000Z","updated":"2016-10-14T06:46:44.917Z","comments":true,"path":"2016/07/01/面向对象 第一天 /","link":"","permalink":"http://ihuzb.huzb.vip/2016/07/01/面向对象 第一天 /","excerpt":"面向对象学习第一天，数据类型，内置对象，判断数据类型。","text":"面向对象学习第一天，数据类型，内置对象，判断数据类型。 面向对象 第一天之前知识复习1.JavaScript由几部分构成 ECMAScript DOM BOM 2.数据类型有哪些？ 基本数据类型 number string boolean null undefined 复杂数据类型 object 3.ECMAScript内置对象有哪些？都是Object类型下的对象 Array Math Date Object String Number Boolean Function Error RegExp 4.如何判断数据类型？ typeof 无法判断null类型的数据，返回值是Object，反过来说tupeof判断object类型的数据可能存在误判 可以判断Function类型的对象 5.基本类型与引用类型的赋值 基本类型赋值 var a=1; var b=a 赋值时copy具体的值 引用类型赋值 赋值时copy的是对象的地址6.运算符 算数运算符+ % 算数运算，字符串链接，把数据类型转换成number %取余数 逻辑运算符&amp;&amp; || ！ &amp;&amp; 从左往右，依次把数据转换成boolean类型，如果是false，则返回对应的数据，如果一直没有找到，则返回最后一个数据 || 从左往右，依次把数据转换成boolean类型，如果是true，则返回对应的数据，如果一直没有找到，则返回最后一个数据 ！ 把数据转换成boolean类型，然后器反值 相等运算副 === 类型与值必须全等 == 会先进性数据类型转换，在比较==三元运算符？ ： ？前面的表达式结果为true，执行冒号前面的代码式，否则执行后面的表达式-6.布尔类型转换 把数据转换成布尔类型 ！！Booleab 那些数据可以转换成boolean类型结果为false 0，undefined，null，Nan，‘’ 所有对象转换后为boolean类型，都为true7.语句 分支语句 if else swith case 循环语句 for while do while for in break和continue的作用 break：结束循环 continue：跳出当前循环8.函数 创建方法 函数声明式 函数表达式 Function 参数 对函数中重复执行代码中的不同部分的抽象提取 形参是用来接收实参传递过来的值 返回值 如果没有return语句，则为undefined，如果有则为对应的值 默认返回值为undefined arguments arguments是一个代表实参的对象，可以通过下标的方式获取实参的个数 arguments是一个可以在函数中使用的关键字 通过他可以通过下标的方式获取带所有的实参 还有一个length属性，用来获取实参的个数 arguments.length 需要注意：arguments不是数组，它是一个对象 像这种拥有length属性，以下标存储数据的对象，统一称之为伪数组 arguments类似这个样子：{ 0:&quot;实参1&quot;,1:&quot;实参2&quot;,length:2} this 谁调用就指向谁 throw错误抛出 throw 自定义抛出错误 debugger与断点 +号 如果两边含有字符串或者对象，那么转换为string之后再相加 除此之外，两数相加，转换为number后进行相加 -号把两边的转换位number后进行相减 类型相等比较 约定：非空数据类型表示null和undefined两种数据类型 任何数据和NaN相比都是false null和非空类型相比结果为false null等于undefined undefined和非空类型相比结果为false 数字和非空类型比较，先转换为数字在比较 布尔和非空类型比较，先转换为数字再比较 对象与对象比较内存地址 对象与字符串，对象先转换为字符串再比较- 动态作用域：如果在函数内访问一个变量，优先找局部变量和形参，如果没有找到，去调用该函数的环境中查找","categories":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ihuzb.huzb.vip/tags/JavaScript/"}],"keywords":[{"name":"学习资料","slug":"学习资料","permalink":"http://ihuzb.huzb.vip/categories/学习资料/"}]}]}